"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MixedType = void 0;
const utils_1 = require("./utils");
const locales_1 = __importDefault(require("./locales"));
class MixedType {
    constructor(name) {
        this.required = false;
        this.requiredMessage = '';
        this.trim = false;
        this.emptyAllowed = false;
        this.rules = [];
        this.priorityRules = [];
        this.typeName = name;
        this.locale = Object.assign(name ? locales_1.default[name] : {}, locales_1.default.mixed);
    }
    setSchemaOptions(schemaSpec, value) {
        this.schemaSpec = schemaSpec;
        this.value = value;
    }
    check(value = this.value, data, fieldName) {
        if (this.required && !(0, utils_1.checkRequired)(value, this.trim, this.emptyAllowed)) {
            return {
                hasError: true,
                errorMessage: (0, utils_1.formatErrorMessage)(this.requiredMessage, { name: fieldName })
            };
        }
        const validator = (0, utils_1.createValidator)(data, fieldName);
        const checkStatus = validator(value, this.priorityRules);
        if (checkStatus) {
            return checkStatus;
        }
        if (!this.required && (0, utils_1.isEmpty)(value)) {
            return { hasError: false };
        }
        return validator(value, this.rules) || { hasError: false };
    }
    checkAsync(value = this.value, data, fieldName) {
        if (this.required && !(0, utils_1.checkRequired)(value, this.trim, this.emptyAllowed)) {
            return Promise.resolve({
                hasError: true,
                errorMessage: (0, utils_1.formatErrorMessage)(this.requiredMessage, { name: fieldName })
            });
        }
        const validator = (0, utils_1.createValidatorAsync)(data, fieldName);
        return new Promise(resolve => validator(value, this.priorityRules)
            .then((checkStatus) => {
            if (checkStatus) {
                resolve(checkStatus);
            }
        })
            .then(() => {
            if (!this.required && (0, utils_1.isEmpty)(value)) {
                resolve({ hasError: false });
            }
        })
            .then(() => validator(value, this.rules))
            .then((checkStatus) => {
            if (checkStatus) {
                resolve(checkStatus);
            }
            resolve({ hasError: false });
        }));
    }
    pushRule(rule) {
        var _a, _b;
        const { onValid, errorMessage, priority, params } = rule;
        const nextRule = {
            onValid,
            params,
            isAsync: rule.isAsync,
            errorMessage: errorMessage || ((_b = (_a = this.rules) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.errorMessage)
        };
        if (priority) {
            this.priorityRules.push(nextRule);
        }
        else {
            this.rules.push(nextRule);
        }
    }
    addRule(onValid, errorMessage, priority) {
        this.pushRule({ onValid, errorMessage, priority });
        return this;
    }
    addAsyncRule(onValid, errorMessage, priority) {
        this.pushRule({ onValid, isAsync: true, errorMessage, priority });
        return this;
    }
    isRequired(errorMessage = this.locale.isRequired, trim = true) {
        this.required = true;
        this.trim = trim;
        this.requiredMessage = errorMessage;
        return this;
    }
    isRequiredOrEmpty(errorMessage = this.locale.isRequiredOrEmpty, trim = true) {
        this.required = true;
        this.trim = trim;
        this.emptyAllowed = true;
        this.requiredMessage = errorMessage;
        return this;
    }
    /**
     * Define data verification rules based on conditions.
     * @param validator
     * @example
     * MixedType().when(schema => {
     *   return schema.filed1.check() ? NumberType().min(5) : NumberType().min(0);
     * });
     */
    when(condition) {
        this.addRule((value, data, filedName) => {
            return condition(this.schemaSpec).check(value, data, filedName);
        }, undefined, true);
        return this;
    }
}
exports.MixedType = MixedType;
function getMixedType() {
    return new MixedType();
}
exports.default = getMixedType;
//# sourceMappingURL=MixedType.js.map