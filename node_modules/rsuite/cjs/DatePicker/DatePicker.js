'use client';
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _react = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _mapValues = _interopRequireDefault(require("lodash/mapValues"));
var _pick = _interopRequireDefault(require("lodash/pick"));
var _omit = _interopRequireDefault(require("lodash/omit"));
var _delay = _interopRequireDefault(require("lodash/delay"));
var _debounce = _interopRequireDefault(require("lodash/debounce"));
var _Calendar = _interopRequireDefault(require("@rsuite/icons/legacy/Calendar"));
var _ClockO = _interopRequireDefault(require("@rsuite/icons/legacy/ClockO"));
var _CalendarContainer = _interopRequireDefault(require("../Calendar/CalendarContainer"));
var _useCalendarDate2 = _interopRequireDefault(require("../Calendar/useCalendarDate"));
var _MonthDropdown = require("../Calendar/MonthDropdown");
var _Toolbar = _interopRequireDefault(require("./Toolbar"));
var _Stack = _interopRequireDefault(require("../Stack"));
var _PredefinedRanges = _interopRequireDefault(require("./PredefinedRanges"));
var _utils = require("../utils");
var _dateUtils = require("../utils/dateUtils");
var _Picker = require("../Picker");
var _OverlayTrigger = require("../Overlay/OverlayTrigger");
var _deprecatePropType = require("../utils/deprecatePropType");
var _utils2 = require("../Calendar/utils");
var DatePicker = /*#__PURE__*/_react.default.forwardRef(function (props, ref) {
  var _props$as = props.as,
    Component = _props$as === void 0 ? 'div' : _props$as,
    className = props.className,
    _props$classPrefix = props.classPrefix,
    classPrefix = _props$classPrefix === void 0 ? 'picker' : _props$classPrefix,
    calendarDefaultDate = props.calendarDefaultDate,
    _props$cleanable = props.cleanable,
    cleanable = _props$cleanable === void 0 ? true : _props$cleanable,
    _props$editable = props.editable,
    editable = _props$editable === void 0 ? true : _props$editable,
    defaultValue = props.defaultValue,
    disabled = props.disabled,
    _props$format = props.format,
    formatStr = _props$format === void 0 ? 'yyyy-MM-dd' : _props$format,
    isoWeek = props.isoWeek,
    _props$limitEndYear = props.limitEndYear,
    limitEndYear = _props$limitEndYear === void 0 ? 1000 : _props$limitEndYear,
    limitStartYear = props.limitStartYear,
    overrideLocale = props.locale,
    menuClassName = props.menuClassName,
    _props$appearance = props.appearance,
    appearance = _props$appearance === void 0 ? 'default' : _props$appearance,
    _props$placement = props.placement,
    placement = _props$placement === void 0 ? 'bottomStart' : _props$placement,
    oneTap = props.oneTap,
    _props$placeholder = props.placeholder,
    placeholder = _props$placeholder === void 0 ? '' : _props$placeholder,
    ranges = props.ranges,
    valueProp = props.value,
    showMeridian = props.showMeridian,
    showWeekNumbers = props.showWeekNumbers,
    style = props.style,
    toggleAs = props.toggleAs,
    caretAsProp = props.caretAs,
    DEPRECATED_disabledDate = props.disabledDate,
    DEPRECATED_disabledHours = props.disabledHours,
    DEPRECATED_disabledMinutes = props.disabledMinutes,
    DEPRECATED_disabledSeconds = props.disabledSeconds,
    shouldDisableDate = props.shouldDisableDate,
    shouldDisableHour = props.shouldDisableHour,
    shouldDisableMinute = props.shouldDisableMinute,
    shouldDisableSecond = props.shouldDisableSecond,
    renderValue = props.renderValue,
    onChange = props.onChange,
    onChangeCalendarDate = props.onChangeCalendarDate,
    onClean = props.onClean,
    onClose = props.onClose,
    onEntered = props.onEntered,
    onExited = props.onExited,
    onNextMonth = props.onNextMonth,
    onOk = props.onOk,
    onOpen = props.onOpen,
    onPrevMonth = props.onPrevMonth,
    onSelect = props.onSelect,
    onToggleMonthDropdown = props.onToggleMonthDropdown,
    onToggleTimeDropdown = props.onToggleTimeDropdown,
    onShortcutClick = props.onShortcutClick,
    rest = (0, _objectWithoutPropertiesLoose2.default)(props, ["as", "className", "classPrefix", "calendarDefaultDate", "cleanable", "editable", "defaultValue", "disabled", "format", "isoWeek", "limitEndYear", "limitStartYear", "locale", "menuClassName", "appearance", "placement", "oneTap", "placeholder", "ranges", "value", "showMeridian", "showWeekNumbers", "style", "toggleAs", "caretAs", "disabledDate", "disabledHours", "disabledMinutes", "disabledSeconds", "shouldDisableDate", "shouldDisableHour", "shouldDisableMinute", "shouldDisableSecond", "renderValue", "onChange", "onChangeCalendarDate", "onClean", "onClose", "onEntered", "onExited", "onNextMonth", "onOk", "onOpen", "onPrevMonth", "onSelect", "onToggleMonthDropdown", "onToggleTimeDropdown", "onShortcutClick"]);
  var _useCustom = (0, _utils.useCustom)('DatePicker', overrideLocale),
    locale = _useCustom.locale,
    formatDate = _useCustom.formatDate,
    parseDate = _useCustom.parseDate;
  var _useClassNames = (0, _utils.useClassNames)(classPrefix),
    merge = _useClassNames.merge,
    prefix = _useClassNames.prefix;
  var _useControlled = (0, _utils.useControlled)(valueProp, defaultValue),
    value = _useControlled[0],
    setValue = _useControlled[1];
  var _useCalendarDate = (0, _useCalendarDate2.default)(value, calendarDefaultDate),
    calendarDate = _useCalendarDate.calendarDate,
    setCalendarDate = _useCalendarDate.setCalendarDate,
    resetCalendarDate = _useCalendarDate.resetCalendarDate;
  var _useState = (0, _react.useState)(false),
    showMonthDropdown = _useState[0],
    setShowMonthDropdown = _useState[1]; // Show only the calendar month panel. formatStr = 'yyyy-MM'
  var onlyShowMonth = (0, _dateUtils.shouldRenderMonth)(formatStr) && !(0, _dateUtils.shouldRenderDate)(formatStr);
  var showMonth = onlyShowMonth || showMonthDropdown;
  var _useState2 = (0, _react.useState)(),
    inputState = _useState2[0],
    setInputState = _useState2[1];
  var _useState3 = (0, _react.useState)(false),
    active = _useState3[0],
    setActive = _useState3[1];
  var triggerRef = (0, _react.useRef)(null);
  var rootRef = (0, _react.useRef)(null);
  var targetRef = (0, _react.useRef)(null);
  var overlayRef = (0, _react.useRef)(null);
  (0, _Picker.usePublicMethods)(ref, {
    rootRef: rootRef,
    triggerRef: triggerRef,
    overlayRef: overlayRef,
    targetRef: targetRef
  });

  /**
   * Switch to the callback triggered after the next month.
   */
  var handleMoveForward = (0, _react.useCallback)(function (nextPageDate) {
    setCalendarDate(nextPageDate);
    onNextMonth === null || onNextMonth === void 0 ? void 0 : onNextMonth(nextPageDate);
    onChangeCalendarDate === null || onChangeCalendarDate === void 0 ? void 0 : onChangeCalendarDate(nextPageDate);
  }, [onChangeCalendarDate, onNextMonth, setCalendarDate]);

  /**
   * Switch to the callback triggered after the previous month.
   */
  var handleMoveBackward = (0, _react.useCallback)(function (nextPageDate) {
    setCalendarDate(nextPageDate);
    onPrevMonth === null || onPrevMonth === void 0 ? void 0 : onPrevMonth(nextPageDate);
    onChangeCalendarDate === null || onChangeCalendarDate === void 0 ? void 0 : onChangeCalendarDate(nextPageDate);
  }, [onChangeCalendarDate, onPrevMonth, setCalendarDate]);

  /**
   * The callback triggered when the date changes.
   */
  var handleDateChange = (0, _react.useCallback)(function (nextValue, event) {
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(nextValue, event);
    onChangeCalendarDate === null || onChangeCalendarDate === void 0 ? void 0 : onChangeCalendarDate(nextValue, event);
  }, [onChangeCalendarDate, onSelect]);

  /**
   *  A callback triggered when the time on the calendar changes.
   */
  var handleChangeTime = (0, _react.useCallback)(function (nextPageTime) {
    setCalendarDate(nextPageTime);
    handleDateChange(nextPageTime);
  }, [handleDateChange, setCalendarDate]);
  var handleClose = (0, _react.useCallback)(function () {
    var _triggerRef$current, _triggerRef$current$c;
    (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : (_triggerRef$current$c = _triggerRef$current.close) === null || _triggerRef$current$c === void 0 ? void 0 : _triggerRef$current$c.call(_triggerRef$current);
  }, []);

  /**
   * The callback triggered when PM/AM is switched.
   */
  var handleToggleMeridian = (0, _react.useCallback)(function () {
    var hours = (0, _dateUtils.getHours)(calendarDate);
    var nextHours = hours >= 12 ? hours - 12 : hours + 12;
    var nextDate = (0, _dateUtils.setHours)(calendarDate, nextHours);
    handleChangeTime(nextDate);
  }, [calendarDate, handleChangeTime]);
  var updateValue = (0, _react.useCallback)(function (event, nextPageDate, closeOverlay) {
    if (closeOverlay === void 0) {
      closeOverlay = true;
    }
    var nextValue = typeof nextPageDate !== 'undefined' ? nextPageDate : calendarDate;
    setCalendarDate(nextValue || new Date());
    setValue(nextValue);
    if (nextValue !== value) {
      onChange === null || onChange === void 0 ? void 0 : onChange(nextValue, event);
    }

    // `closeOverlay` default value is `true`
    if (closeOverlay !== false) {
      handleClose();
    }
  }, [handleClose, onChange, calendarDate, setCalendarDate, setValue, value]);

  /**
   * The callback triggered after the date in the shortcut area is clicked.
   */
  var handleShortcutPageDate = (0, _react.useCallback)(function (range, closeOverlay, event) {
    var value = range.value;
    updateValue(event, value, closeOverlay);
    handleDateChange(value, event);
    onShortcutClick === null || onShortcutClick === void 0 ? void 0 : onShortcutClick(range, event);
  }, [handleDateChange, onShortcutClick, updateValue]);

  /**
   * Get the corresponding container based on date selection and month selection
   */
  var getOverlayContainer = (0, _react.useCallback)(function () {
    var _overlayRef$current;
    return (_overlayRef$current = overlayRef.current) === null || _overlayRef$current === void 0 ? void 0 : _overlayRef$current.querySelector(showMonth ? '[role="menu"]' : '[role="grid"]');
  }, [showMonth]);

  /**
   * Check whether the date is focusable
   */
  var checkFocusable = (0, _react.useCallback)(function (date) {
    var formatStr = showMonth ? locale.formattedMonthPattern : locale.formattedDayPattern;
    var ariaLabel = (0, _utils2.getAriaLabel)(date, formatStr, formatDate);
    var container = getOverlayContainer();
    var dateElement = container.querySelector("[aria-label=\"" + ariaLabel + "\"]");
    if (dateElement !== null && dateElement !== void 0 && dateElement.hasAttribute('aria-disabled')) {
      return false;
    }
    return true;
  }, [formatDate, getOverlayContainer, locale, showMonth]);

  /**
   * Focus on the currently selected date element
   */
  var focusSelectedDate = (0, _react.useCallback)(function () {
    (0, _delay.default)(function () {
      var container = getOverlayContainer();
      var selectedElement = container === null || container === void 0 ? void 0 : container.querySelector('[aria-selected="true"]');
      selectedElement === null || selectedElement === void 0 ? void 0 : selectedElement.focus();
    }, 1);
  }, [getOverlayContainer]);

  /**
   * Focus on the input element
   */
  var focusTargetButton = (0, _react.useCallback)(function () {
    (0, _delay.default)(function () {
      var _targetRef$current, _targetRef$current$qu;
      (_targetRef$current = targetRef.current) === null || _targetRef$current === void 0 ? void 0 : (_targetRef$current$qu = _targetRef$current.querySelector('input')) === null || _targetRef$current$qu === void 0 ? void 0 : _targetRef$current$qu.focus();
    }, 100);
  }, []);

  /**
   * The callback triggered after clicking the OK button.
   */
  var handleOK = (0, _react.useCallback)(function (event) {
    updateValue(event);
    onOk === null || onOk === void 0 ? void 0 : onOk(calendarDate, event);
    focusTargetButton();
  }, [updateValue, onOk, calendarDate, focusTargetButton]);

  /**
   * Callback after clicking the clear button.
   */
  var handleClean = (0, _react.useCallback)(function (event) {
    updateValue(event, null);
    resetCalendarDate(null);
  }, [resetCalendarDate, updateValue]);
  var handlePickerToggleKeyDown = (0, _react.useCallback)(function (event) {
    var _event$target;
    var tagName = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.tagName;
    if (tagName === 'INPUT') {
      if (event.key === 'ArrowDown') {
        event.preventDefault();
        focusSelectedDate();
      } else if (event.key === 'Enter') {
        var _triggerRef$current2, _triggerRef$current2$;
        (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : (_triggerRef$current2$ = _triggerRef$current2.open) === null || _triggerRef$current2$ === void 0 ? void 0 : _triggerRef$current2$.call(_triggerRef$current2);
      }
    }
  }, [focusSelectedDate]);
  var handlePickerOverlayKeyDown = (0, _react.useCallback)(function (event) {
    var delta = 0;
    var step = showMonth ? 6 : 7;
    var changeDateFunc = showMonth ? _dateUtils.addMonths : _dateUtils.addDays;
    (0, _Picker.onMenuKeyDown)(event, {
      down: function down() {
        delta = step;
      },
      up: function up() {
        delta = -step;
      },
      right: function right() {
        delta = 1;
      },
      left: function left() {
        delta = -1;
      },
      enter: function enter() {
        handleOK(event);
      }
    });
    var nextDate = changeDateFunc(calendarDate, delta);
    if (checkFocusable(nextDate)) {
      setCalendarDate(nextDate);
      focusSelectedDate();
    }
  }, [showMonth, calendarDate, checkFocusable, handleOK, setCalendarDate, focusSelectedDate]);

  /**
   * The callback triggered after the month selection box is opened or closed.
   */
  var handleToggleMonthDropdown = (0, _react.useCallback)(function (toggle) {
    onToggleMonthDropdown === null || onToggleMonthDropdown === void 0 ? void 0 : onToggleMonthDropdown(toggle);
    setShowMonthDropdown(toggle);
  }, [onToggleMonthDropdown]);

  /**
   * Handle keyboard events.
   */
  var onPickerKeyDown = (0, _Picker.useToggleKeyDownEvent)((0, _extends2.default)({
    triggerRef: triggerRef,
    targetRef: targetRef,
    overlayRef: overlayRef,
    active: active,
    onExit: handleClean,
    onKeyDown: handlePickerToggleKeyDown
  }, rest));

  /**
   * Callback after the date is selected.
   */
  var handleSelect = (0, _react.useCallback)(function (nextValue, event, updatableValue) {
    if (updatableValue === void 0) {
      updatableValue = true;
    }
    setCalendarDate(
    // Determine whether the current value contains time, if not, use calendarDate.
    (0, _dateUtils.shouldRenderTime)(formatStr) ? nextValue : (0, _utils.composeFunctions)(function (d) {
      return (0, _dateUtils.setHours)(d, (0, _dateUtils.getHours)(calendarDate));
    }, function (d) {
      return (0, _dateUtils.setMinutes)(d, (0, _dateUtils.getMinutes)(calendarDate));
    }, function (d) {
      return (0, _dateUtils.setSeconds)(d, (0, _dateUtils.getSeconds)(calendarDate));
    })(nextValue));
    handleDateChange(nextValue);
    if (oneTap && updatableValue) {
      updateValue(event, nextValue);
    }
  }, [setCalendarDate, formatStr, handleDateChange, oneTap, calendarDate, updateValue]);

  /**
   *  A callback triggered when the date on the calendar changes.
   */
  var handleChangeMonth = (0, _react.useCallback)(function (nextPageDate, event) {
    setCalendarDate(nextPageDate);
    handleDateChange(nextPageDate);
    focusSelectedDate();
    if (oneTap && onlyShowMonth) {
      updateValue(event, nextPageDate);
    }
  }, [focusSelectedDate, handleDateChange, oneTap, onlyShowMonth, setCalendarDate, updateValue]);
  var isDateDisabled = (0, _react.useCallback)(function (date) {
    if (typeof shouldDisableDate === 'function') {
      return shouldDisableDate(date);
    }
    if (typeof DEPRECATED_disabledDate === 'function') {
      return DEPRECATED_disabledDate(date);
    }
    return false;
  }, [DEPRECATED_disabledDate, shouldDisableDate]);

  /**
   * Callback after the input box value is changed.
   */
  var handleInputChange = (0, _react.useCallback)(function (value, event) {
    setInputState('Typing');

    // isMatch('01/11/2020', 'MM/dd/yyyy') ==> true
    // isMatch('2020-11-01', 'MM/dd/yyyy') ==> false
    if (!(0, _dateUtils.isMatch)(value, formatStr, {
      locale: locale.dateLocale
    })) {
      setInputState('Error');
      return;
    }
    var date = parseDate(value, formatStr);

    // If only the time is included in the characters, it will default to today.
    if ((0, _dateUtils.shouldOnlyRenderTime)(formatStr)) {
      date = new Date((0, _dateUtils.format)(new Date(), 'yyyy-MM-dd') + " " + value);
    }
    if (!(0, _dateUtils.isValid)(date)) {
      setInputState('Error');
      return;
    }
    if (isDateDisabled(date)) {
      setInputState('Error');
      return;
    }
    handleSelect(date, event, false);
  }, [formatStr, locale, parseDate, isDateDisabled, handleSelect]);

  /**
   * The callback after the enter key is triggered on the input
   */
  var handleInputPressEnd = (0, _react.useCallback)(function (event) {
    if (inputState === 'Typing') {
      updateValue(event, calendarDate);
    }
    setInputState('Initial');
  }, [inputState, calendarDate, updateValue]);
  var handleInputBackspace = (0, _react.useCallback)(function (event) {
    var value = event.target.value;

    // When the input box is empty, the date is cleared.
    if (value === '') {
      handleClean(event);
    }
  }, [handleClean]);
  var handleEntered = (0, _react.useCallback)(function () {
    onOpen === null || onOpen === void 0 ? void 0 : onOpen();
    setActive(true);
  }, [onOpen]);
  var handleExited = (0, _react.useCallback)(function () {
    onClose === null || onClose === void 0 ? void 0 : onClose();
    setActive(false);
  }, [onClose]);

  // Check whether the time is within the time range of the shortcut option in the toolbar.
  var disabledToolbarHandle = (0, _react.useCallback)(function (date) {
    var _DEPRECATED_disabledD;
    var allowDate = (_DEPRECATED_disabledD = DEPRECATED_disabledDate === null || DEPRECATED_disabledDate === void 0 ? void 0 : DEPRECATED_disabledDate(date)) !== null && _DEPRECATED_disabledD !== void 0 ? _DEPRECATED_disabledD : false;
    var allowTime = (0, _dateUtils.disabledTime)(props, date);
    return allowDate || allowTime;
  }, [DEPRECATED_disabledDate, props]);

  /**
   * Whether "OK" button is disabled
   *
   * - If format is date, disable ok button if selected date is disabled
   * - If format is month, disable ok button if all dates in the month of selected date are disabled
   */
  var isOKButtonDisabled = (0, _react.useCallback)(function (selectedDate) {
    if ((0, _dateUtils.shouldRenderMonth)(formatStr) && !(0, _dateUtils.shouldRenderDate)(formatStr)) {
      return (0, _MonthDropdown.isEveryDateInMonth)(selectedDate.getFullYear(), selectedDate.getMonth(), disabledToolbarHandle);
    }
    return disabledToolbarHandle(selectedDate);
  }, [disabledToolbarHandle, formatStr]);
  var calendarProps = (0, _react.useMemo)(function () {
    return (0, _mapValues.default)((0, _pick.default)(props, _dateUtils.calendarOnlyProps), function (disabledOrHiddenTimeFunc) {
      return function (next, date) {
        var _disabledOrHiddenTime;
        return (_disabledOrHiddenTime = disabledOrHiddenTimeFunc === null || disabledOrHiddenTimeFunc === void 0 ? void 0 : disabledOrHiddenTimeFunc(next, date)) !== null && _disabledOrHiddenTime !== void 0 ? _disabledOrHiddenTime : false;
      };
    });
  }, [props]);
  var calendar = /*#__PURE__*/_react.default.createElement(_CalendarContainer.default, (0, _extends2.default)({}, calendarProps, {
    locale: locale,
    showWeekNumbers: showWeekNumbers,
    showMeridian: showMeridian,
    disabledDate: isDateDisabled,
    disabledHours: shouldDisableHour !== null && shouldDisableHour !== void 0 ? shouldDisableHour : DEPRECATED_disabledHours,
    disabledMinutes: shouldDisableMinute !== null && shouldDisableMinute !== void 0 ? shouldDisableMinute : DEPRECATED_disabledMinutes,
    disabledSeconds: shouldDisableSecond !== null && shouldDisableSecond !== void 0 ? shouldDisableSecond : DEPRECATED_disabledSeconds,
    limitEndYear: limitEndYear,
    limitStartYear: limitStartYear,
    format: formatStr,
    isoWeek: isoWeek,
    calendarDate: calendarDate,
    onMoveForward: handleMoveForward,
    onMoveBackward: handleMoveBackward,
    onSelect: handleSelect,
    onToggleMonthDropdown: handleToggleMonthDropdown,
    onToggleTimeDropdown: onToggleTimeDropdown,
    onChangeMonth: handleChangeMonth,
    onChangeTime: handleChangeTime,
    onToggleMeridian: handleToggleMeridian
  }));

  // The shortcut option on the left side of the calendar panel
  var sideRanges = (ranges === null || ranges === void 0 ? void 0 : ranges.filter(function (range) {
    return (range === null || range === void 0 ? void 0 : range.placement) === 'left';
  })) || [];

  // The shortcut option on the bottom of the calendar panel
  var bottomRanges = (ranges === null || ranges === void 0 ? void 0 : ranges.filter(function (range) {
    return (range === null || range === void 0 ? void 0 : range.placement) === 'bottom' || (range === null || range === void 0 ? void 0 : range.placement) === undefined;
  })) || [];
  var renderDropdownMenu = function renderDropdownMenu(positionProps, speakerRef) {
    var left = positionProps.left,
      top = positionProps.top,
      className = positionProps.className;
    var classes = merge(menuClassName, className, prefix('date-menu'));
    var styles = {
      left: left,
      top: top
    };
    return /*#__PURE__*/_react.default.createElement(_Picker.PickerOverlay, {
      role: "dialog",
      className: classes,
      ref: (0, _utils.mergeRefs)(overlayRef, speakerRef),
      style: styles,
      target: triggerRef,
      onKeyDown: handlePickerOverlayKeyDown
    }, /*#__PURE__*/_react.default.createElement(_Stack.default, {
      alignItems: "flex-start"
    }, sideRanges.length > 0 && /*#__PURE__*/_react.default.createElement(_PredefinedRanges.default, {
      direction: "column",
      spacing: 0,
      className: prefix('date-predefined'),
      ranges: sideRanges,
      calendarDate: calendarDate,
      locale: locale,
      disabledShortcut: disabledToolbarHandle,
      onShortcutClick: handleShortcutPageDate
    }), /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, calendar, /*#__PURE__*/_react.default.createElement(_Toolbar.default, {
      locale: locale,
      ranges: bottomRanges,
      calendarDate: calendarDate,
      disabledOkBtn: isOKButtonDisabled,
      disabledShortcut: disabledToolbarHandle,
      onShortcutClick: handleShortcutPageDate,
      onOk: handleOK,
      hideOkBtn: oneTap
    }))));
  };
  var hasValue = !!value;
  var _usePickerClassName = (0, _Picker.usePickerClassName)((0, _extends2.default)({}, props, {
      classPrefix: classPrefix,
      name: 'date',
      appearance: appearance,
      hasValue: hasValue,
      cleanable: cleanable
    })),
    classes = _usePickerClassName[0],
    usedClassNamePropKeys = _usePickerClassName[1];
  var renderDate = (0, _react.useCallback)(function () {
    var _renderValue;
    if (!value) {
      return placeholder || formatStr;
    }
    return (_renderValue = renderValue === null || renderValue === void 0 ? void 0 : renderValue(value, formatStr)) !== null && _renderValue !== void 0 ? _renderValue : formatDate(value, formatStr);
  }, [formatStr, formatDate, placeholder, renderValue, value]);
  var caretAs = (0, _react.useMemo)(function () {
    return caretAsProp || ((0, _dateUtils.shouldOnlyRenderTime)(formatStr) ? _ClockO.default : _Calendar.default);
  }, [caretAsProp, formatStr]);
  var handleTriggerClose = (0, _react.useCallback)(function (cause) {
    // Unless overlay is closing on user clicking "OK" button,
    // reset the selected date on calendar panel
    if (cause !== _OverlayTrigger.OverlayCloseCause.ImperativeHandle) {
      resetCalendarDate();
    }
    setShowMonthDropdown(false);
  }, [resetCalendarDate]);
  return /*#__PURE__*/_react.default.createElement(_Picker.PickerToggleTrigger, {
    trigger: "active",
    pickerProps: (0, _pick.default)(props, _Picker.pickTriggerPropKeys),
    ref: triggerRef,
    placement: placement,
    onClose: handleTriggerClose,
    onEntered: (0, _utils.createChainedFunction)(handleEntered, onEntered),
    onExited: (0, _utils.createChainedFunction)(handleExited, onExited),
    speaker: renderDropdownMenu
  }, /*#__PURE__*/_react.default.createElement(Component, {
    className: merge(className, classes),
    style: style,
    ref: rootRef
  }, /*#__PURE__*/_react.default.createElement(_Picker.PickerToggle, (0, _extends2.default)({}, (0, _omit.default)(rest, [].concat(_Picker.omitTriggerPropKeys, usedClassNamePropKeys, _dateUtils.calendarOnlyProps)), {
    className: prefix({
      error: inputState === 'Error'
    }),
    as: toggleAs,
    ref: targetRef,
    appearance: appearance,
    editable: editable,
    inputValue: value ? formatDate(value, formatStr) : '',
    inputPlaceholder: typeof placeholder === 'string' && placeholder ? placeholder : formatStr,
    inputMask: (0, _dateUtils.getDateMask)(formatStr),
    onInputChange: handleInputChange,
    onInputBlur: handleInputPressEnd,
    onInputPressEnter: handleInputPressEnd,
    onInputBackspace: (0, _debounce.default)(handleInputBackspace, 10),
    onKeyDown: onPickerKeyDown,
    onClean: (0, _utils.createChainedFunction)(handleClean, onClean),
    cleanable: cleanable && !disabled,
    hasValue: hasValue,
    active: active,
    placement: placement,
    disabled: disabled,
    caretAs: caretAs,
    "aria-haspopup": "dialog"
  }), renderDate())));
});
DatePicker.displayName = 'DatePicker';
DatePicker.propTypes = (0, _extends2.default)({}, _Picker.pickerPropTypes, {
  calendarDefaultDate: _propTypes.default.instanceOf(Date),
  defaultValue: _propTypes.default.instanceOf(Date),
  disabledDate: (0, _deprecatePropType.deprecatePropTypeNew)(_propTypes.default.func, 'Use "shouldDisableDate" property instead.'),
  disabledHours: (0, _deprecatePropType.deprecatePropTypeNew)(_propTypes.default.func, 'Use "shouldDisableHour" property instead.'),
  disabledMinutes: (0, _deprecatePropType.deprecatePropTypeNew)(_propTypes.default.func, 'Use "shouldDisableMinute" property instead.'),
  disabledSeconds: (0, _deprecatePropType.deprecatePropTypeNew)(_propTypes.default.func, 'Use "shouldDisableSecond" property instead.'),
  shouldDisableDate: _propTypes.default.func,
  shouldDisableHour: _propTypes.default.func,
  shouldDisableMinute: _propTypes.default.func,
  shouldDisableSecond: _propTypes.default.func,
  format: _propTypes.default.string,
  hideHours: _propTypes.default.func,
  hideMinutes: _propTypes.default.func,
  hideSeconds: _propTypes.default.func,
  isoWeek: _propTypes.default.bool,
  limitEndYear: _propTypes.default.number,
  limitStartYear: _propTypes.default.number,
  onChange: _propTypes.default.func,
  onChangeCalendarDate: _propTypes.default.func,
  onNextMonth: _propTypes.default.func,
  onOk: _propTypes.default.func,
  onPrevMonth: _propTypes.default.func,
  onSelect: _propTypes.default.func,
  onToggleMonthDropdown: _propTypes.default.func,
  onToggleTimeDropdown: _propTypes.default.func,
  oneTap: _propTypes.default.bool,
  panelContainerRef: _propTypes.default.any,
  ranges: _propTypes.default.array,
  showMeridian: _propTypes.default.bool,
  showWeekNumbers: _propTypes.default.bool,
  value: _propTypes.default.instanceOf(Date)
});
var _default = DatePicker;
exports.default = _default;